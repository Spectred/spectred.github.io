---
sidebar: 'auto'
sidebarDepth: 1
---

# JVM

## 1. JVM通过可达性分析算法来判断对象是否存活，那么可做为`GC Roots`的对象有哪些?

> [深入理解Java虚拟机](https://book.douban.com/subject/34907497/) 3.2.2 可达性分析算法

- 在**虚拟机栈**(栈帧中的局部变量表)中引用的对象，譬如各个线程被调用的堆栈中使用到的参数、局部变量表和临时变量等
- 在**方法区**中类静态属性引用的对象，譬如Java类的引用类型静态变量
- 在**方法区**中常量引用的对象，譬如字符串常量池(`String Table`)里的引用
- 在**本地方法栈**中`JNI`(Native方法)引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，常驻的异常对象(NPE,OOM)等，还有系统类加载器
- 所有被同步锁(`synchronized`关键字)持有的对象
- 反省Java虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等
- 根据用户选择的垃圾收集器以及当前回收的内存区域的不同，“临时性”加入的的其他对象

## 2. Java中有哪些引用类型?

>[深入理解Java虚拟机](https://book.douban.com/subject/34907497/) 3.2.3 再谈引用

- 强引用: 发生GC时不会被回收。例如:`Object obj = new Object();`
- 软引用: 有用但不是必须的对象，在发生OOM之前会被回收
- 弱引用: 强度比软引用更弱些的非必须得对象，在下一次GC时会被回收
- 虚引用: 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知

## 3. 有哪些垃圾收集算法

> 3.3 垃圾收集算法

主流JVM采用“追踪式垃圾收集”(Tracing GC)，遵循“分代收集”的理论，建立在分代假说之上:

- 弱分代假说: 绝大多数对象都是朝生夕灭的
- 强分代假说: 熬过越多次垃圾收集过程的对象就越难以消亡
- 跨代引用假说: 跨代引用相当于同代引用来说仅占极少数

> 新生代收集（`Minor GC/Young GC`）: 指目标只是新生代的垃圾收集
>
> 老年代收集（`Major GC/Old GC`）: 指目标只是老年代的GC(只有CMS收集器有单独收集的行为)
>
> 混合收集（`Mixed GC`）: 指目标是收集整个新生代以及部分老年代的手机(只有G1有这种行为)
>
> 整堆收集（`Full GC`）: 收集整个Java堆和方法区的垃圾收集

### 3.1 标记-清除算法 (`Mark-Sweep`)

标记: 标记出可以回收的对象(判定对象是否属于垃圾的过程)，清除:  回收被标记的对象所占用的空间 

主要有两个缺点: 

- 一是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，此时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
- 二是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后再程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

### 3.2 标记-复制算法 （`Mark-Copying`）

将内存空间划分为两个相等的区域，每次只使用其中一个区域。垃圾收集时遍历当前使用的区域，把存活对象复制到另一个区域中，最后将当前使用区域对象进行回收。一般用于新生代，`s0`和`s1`

优点: 实现简单，运行高效，不用考虑内存碎片

缺点: 可用的内存大小缩小为原来的一半，对象存活率高是会频繁复制

### 3.3 标记-整理算法 （`Mark-Compact`）

标记: 标记出可以回收的对象，整理: 让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

优点: 解决了标记-清理算法存在的内存碎片问题

缺点: 仍然需要进行局部对象的移动会减低效率

> 关注吞吐量的`Parallel Scavenge`收集器基于标记-整理
>
> 关注延迟的`CMS`基于标记-清除
>
> CMS: 不在内存分配和访问上增加太大额外负担: 平时采用标记-清除，暂时容忍内存碎片，直到碎片化程度已经大到影响对象分配时，再采用一次标记-整理算法收集一次，以获得规整的内存空间。

## 4. HotSpot的算法细节实现

> 3.4 HotSpot的算法细节实现

1. 根节点枚举
2. 安全点
3. 安全区域
4. 记忆集与卡表
5. 写屏障
6. 并发的可达性分析

## 5. 有哪些垃圾收集器

各款收集器之间的关系: 

> ParNew + CMS
>
> PS+PO

#### 5.1  `Serial`

复制算法，新生代单线程收集器，标记和清理都是单线程

#### 5.2 `ParNew`

复制算法，新生代并行收集器，是`Serial`的多线程版，可和`CMS`搭配

#### 5.3 `Parallel Scavenge`

复制算法，新生代并行收集器，追求高吞吐量

#### 5.4 `Serial Old`

标记-整理算法，老年代单线程收集器，`Serial`收集器的老年代版本

#### 5.5 `Parallel Old`

标记-整理算法，老年代并行收集器，追求高吞吐量，`Parallel Scavenge`的老年代版本

#### 5.6 `CMS`

> -XX:+UseConcMarkSweepGC

`Concurrent Mark Sweep`是一种以获取最短回收停顿时间为目标的收集器，采用标记-清除算法

##### **运作过程**

1) 初始标记(`CMS initial mark`)

   (STW)标记`GC Roots`能直接关联到的对象

2) 并发标记(`CMS concurrent mark`)

   从`GC Roots`的直接关联对象开始遍历整个对象图的过程，耗时长但是和用户线程并发

3) 重新标记(`CMS remark`)

   (STW)修正并发标记期间因用户线程并发产生变动的部分对象标记记录

4) 并发清除（`CMS concurrent sweep`）

   清理删除标记判断的已经死亡的对象，由于不需要移动存活对象，所以也是并发的

##### 缺点

1. `CMS`收集器对处理器资源敏感

   默认启动回收线程数是(处理器核心数量+3)/4,当处理器核心数小于4时对用户程序的影响变大

2. 由于`CMS`无法处理“浮动垃圾”，有可能出现`Concurrent Mode Failure`失败进而导致另一次完全`STW`的`FullGC`产生

   `CMS`必须预留一部分空间供并发收集时的程序运作，在JDK6时`CMS`的启动阈值是`92%`，如果`CMS`运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次并发失败(`Concurrent Mode Failure`)，此时虚拟机将冻结用户线程的执行，临时启用`Serial Old`来重新进行老年代的垃圾收集，停顿时间加长

   > `-XX:CMSInitiatingOccupoancyFraction`来设置阈值百分比，设置的太高会导致大量的并发失败性能降低，要根据实际情况设置

3. `CMS`是基于标记-清除算法的收集器，会产生大量内存碎片

   当空间碎片过多时，会给大对象分配带来麻烦，不得不提前触发一次`Full GC`，对此`CMS`提供了参数

   `-XX:+UseCMSCompactAtFullCollection`默认开启： 不得不进行`Full GC`时开启内存碎片的合并整理过程

   `-XX:CMSFullGCsBeforeCompaction`(默认值是0）要求`CMS`在执行过程若干次(参数值)不整理空间的`FullGC`后，下一次进入`Full GC`前会先进行碎片整理

#### 5.7 `G1`

Java堆(新生代+老年代)并行收集器，基于标记-整理算法实现

`G1`是基于`Region`的堆内存布局，可以面对内存任何部分来**回收集**（Collection Set,CSet）进行回收，衡量的标准不再是属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收效益最大，是`G1`的`Mixed GC`模式。

`G1`将连续的Java堆划分为多个大小相等的独立的区域`Region`,每一个区域根据需要扮演Eden，Survivor或老年代空间，还有一类特殊的`Humongous`区域用来存储大对象（`G1`认为只要超过了一个区域容量一半的对象即可判定为大对象）

> 每个`Region`的大小可以通过参数`-XX:G1HeapRegionSize`进行设定，取值范围是1MB~32MB,且应为2的N次幂

##### 为什么叫`Garbage First`?

`G1`能建立可预测的停顿时间模型，因为它将区域作为单次回收的最小单元，即每次收集到的内存空间都是`Region`大小的整数倍，可以有计划地避免在整个Java堆中进行全区域的垃圾收集。让`G1`去跟踪各个`Region`里的垃圾堆积的“价值”大小(价值: 回收所获得的空间大小以及回收所需时间的经验值)，然后再后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间(`-XX:MaxGCPauseMills`)指定，默认200ms，**优先处理回收价值收益最大的那些`Region`**

##### Java堆分为多个独立`Region`后，`Region`里面存在的跨`Region`引用的对象如何解决?

使用记忆集避免全堆作为`GC Roots`扫描，`G1`的记忆集在存储结构的本质上是一种哈希表(K: 其他区域的起始地址，V是卡表的索引号的集合)，双向的卡表结构（"我指向谁"，"谁指向我"）

##### 并发标记阶段如何保证收集线程和用户线程互不干扰的运行?

- 用户线程改变对象引用关系是，必须保证不能打破原来的对象图结构，导致标记结果出现错误，`G1`采用原始快照`SATB`算法（`CMS`采用增量更新算法）
- 回收过程汇总新创建对象的内存分配上，`G1`为每一个`Region`设计了两个名为`TAMS`（Top At Mark Start）的指针，把区域中的一部分空间划分出来用于并发回收过程中的新对象的分配，并发回收时新分配的对象地址都必须要在这两个指针以上

##### 怎样建立可靠的停顿预测模型?

停顿预测模型是以**衰减均值**为理论基础实现的，在垃圾收集的过程中，`G1`会记录每个`Region`的回收耗时、每个`Region`记忆集里的张卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差和置信度等统计信息

##### 运作过程

- **初始标记** (`Initial Marking`)

  只是标记`GC Roots`能直接关联到的对象，并且修改`TAMS`指针的值，让下一阶段用户线程并发运行时，能正确的在可用的区域中分配区域对象

- **并发标记** (`Concurrent Markding`)

  从`GC Roots`开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，当对象图扫描完成以后，还要重新处理`SATB`记录下的在并发时有引用变动的对象

- **最终标记** (`Final Marking`)

  对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的少量的`SATB`记录

- **筛选回收** (`Live Data Counting and Evacuation`)

  负责更新`Region`的统计数据，对各个`Region`的回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划，可以自由选择任意多个`Region`构成回收集，然后把决定回收的那一部分`Region`的存活对象复制到空的`Region`中，再清理掉整个旧`Region`的全部空间，因为需要移动存活对象，必须要暂停用户线程，由多条收集器线程并行执行

#### 5.8 `ZGC`

> `ZGC`收集器是一款基于`Region`内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器

##### 内存布局

- `Small Region`：容量固定为2MB,存放`(0,256KB)`的小对象
- `Medium Region`: 容量固定为32MB,存放`[256KB,4MB)`的对象
- `Large Region`: 容量不规定，可以动态变化，但必须是2MB的整数倍，用户存放4MB或以上的大对象，每个`Large Region`中只会存放一个大对象，实际最小容量可低至4MB，在`ZGC`的实现中不会被重分配，因为复制一个大对象代价高昂

##### 并发整理算法的实现

采用**染色指针技术**(`Colored Pointeer`)，是一种直接将少量额外的信息存储在指针上的技术，优势有三点:

- 染色指针可以使得一旦某个区域的存活对象被移走后，这个区域立即就能够被释放和重用掉，而不必等待整个堆中所有指向该区域的引用都被修正后才能清理
- 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量
- 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据

##### 运作过程

- **并发标记** （`Concurrent Mark`）

  遍历对象图做可达性分析，`ZGC`的标记是在指针上而不是对象上进行，标记阶段会更新染色指针中的`Marked0`、`Marked1`标志位

- **并发预备重分配** (`Concurrent Prepare for Relocate`)

  需要根据特定的查询条件统计得出本次收集过程要清理哪些区域，将这些区域组成**重分配集**(`Relocation Set`)

- **并发重分配** (`Concurrent Relocate`)

  重分配是`ZGC`执行过程中的核心阶段，要把重分配集中的存活对象复制到新的区域上，并位重分配集中的每个区域维护一个**转发表**(`Forward Table`)，记录从旧对象到新对象的转向关系，得益于染色指针的支持

- **并发重映射** (`Concurrent Remap`)

  修正整个堆中指向重分配集中旧对象的所有引用