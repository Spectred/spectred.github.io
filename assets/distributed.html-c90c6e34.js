import{_ as t,V as r,W as d,Z as e,a3 as a,Y as n,a1 as s,F as i}from"./framework-36369a6e.js";const c={},l=e("h1",{id:"分布式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#分布式","aria-hidden":"true"},"#"),a(" 分布式")],-1),p={href:"https://icyfenix.cn/",target:"_blank",rel:"noopener noreferrer"},h=e("h2",{id:"_1-分布式锁",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-分布式锁","aria-hidden":"true"},"#"),a(" 1. 分布式锁")],-1),u={href:"https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8",target:"_blank",rel:"noopener noreferrer"},k=s(`<p>分布式锁实现多个进程对共享资源的互斥。实现方式上可以采用第三方中间件来做，如<code>MySQL</code>、<code>ZooKeeper</code>、<code>Redis</code>、<code>etcd</code>等</p><h3 id="_1-1-基于关系型数据库-mysql-的分布式锁" tabindex="-1"><a class="header-anchor" href="#_1-1-基于关系型数据库-mysql-的分布式锁" aria-hidden="true">#</a> 1.1 基于关系型数据库(MySQL)的分布式锁</h3><p>悲观锁： <code>select id from t where col = xx for update</code>，会一直阻塞到事务提交，</p><p>乐观锁: <code>select id,old_version from t where col = xx</code>和 <code>update t set ver = old_version+1 where col=xx and ver=old_verison</code></p><h3 id="_1-2-基于redis的分布式锁" tabindex="-1"><a class="header-anchor" href="#_1-2-基于redis的分布式锁" aria-hidden="true">#</a> 1.2 基于Redis的分布式锁</h3><h4 id="_1-2-1-setnx-lock-v-和del-lock" tabindex="-1"><a class="header-anchor" href="#_1-2-1-setnx-lock-v-和del-lock" aria-hidden="true">#</a> 1.2.1 <code>setnx lock v</code> 和<code>del lock</code></h4><p><strong>加锁</strong>时客户端1加锁成功 <code>SETNX lock 1 =&gt; 1</code>,客户端2加锁失败<code>SETNX lock 1 =&gt; 0</code></p><p><strong>解锁</strong>时客户端1 <code>del lock =&gt; 1</code></p><p><strong>存在的问题</strong>: 当客户端1中没能释放锁(如业务异常或进程崩溃)，导致其他客户端一直都拿不到锁，导致死锁 （这种情况需要人工介入解锁）</p><h4 id="_1-2-2-set-lock-v-ex-n-nx" tabindex="-1"><a class="header-anchor" href="#_1-2-2-set-lock-v-ex-n-nx" aria-hidden="true">#</a> 1.2.2 <code>set lock v ex n nx</code></h4><p>为了避免死锁的问题，添加过期时间自动释放锁，用一行命令保证原子性，如<code>set lock 1 ex 10 nx =&gt; OK</code>,其他客户端尝试加锁时返回<code>(nil)</code></p><p><strong>存在的问题:</strong></p><p>A. 过期时间可能不准确，设置少了导致提前释放锁，设置多了会加锁时间过长(一般没这个问题，锁可以释放时可以指定del lock,但是会导致B问题)，</p><p>B. 一个客户端可能释放了其他客户端锁持有的锁</p><h4 id="_1-2-3-set-lock-uuid-ex-n-nx" tabindex="-1"><a class="header-anchor" href="#_1-2-3-set-lock-uuid-ex-n-nx" aria-hidden="true">#</a> 1.2.3 <code>set lock $uuid ex n nx</code></h4><p>对于客户端释放其他客户端持有锁的问题，可以将val设置为一个随机且唯一的值(只有加锁的客户端知道，也可以是线程号)</p><p><strong>加锁</strong>时: <code>set lock 45r8iu ex 10 nx</code></p><p><strong>解锁</strong>时: 采用Lua脚本保证原子性，先判断是否为当前客户端加锁，是的话进行删除</p><div class="language-lua line-numbers-mode" data-ext="lua"><pre class="language-lua"><code><span class="token operator">//</span> 判断锁是自己的，才释放
<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;DEL&quot;</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,19),b={id:"_1-2-4-使用redisson",tabindex:"-1"},f=e("a",{class:"header-anchor",href:"#_1-2-4-使用redisson","aria-hidden":"true"},"#",-1),x={href:"https://github.com/redisson/redisson",target:"_blank",rel:"noopener noreferrer"},g=s('<p>为了解决锁可能提前过期的问题，可以在加锁时设置过期时间，然后通过守护线程定时检测锁的失效时间，如果快过期了但是业务操作还未完成，就自动进行续期</p><blockquote><p>此时，只通过Redis解决分布式锁的方案如下：</p><ol><li>🔐加锁时，采用<code>set lock $uuid ex 10 nx</code>，来保证互斥性，自动失效性，只能加锁客户端解锁，并且开启守护线程检测失效，根据业务决定是否需要续期</li><li>🔓解锁时, 通过Lua脚本保证原子性，先判断是否为客户单加锁，是的话才解锁</li></ol></blockquote><p><strong><code>Redisson</code>的分布式锁原理是怎样的？</strong></p><p><strong>加锁：</strong></p><p>Redisson首先通过hash选择一个redis节点，然后执行加锁的Lua脚本来保证原子性，设置一个hash结构的锁 <code>hset lock $uuid:1 1</code>,其中$uudi:1表示完成了加锁，val的1表示加锁加了一次(可重入)，</p><p>当其他客户段想获取锁时执行同样的脚本先判断key lock是否存在，在判断是否有客户端2的ID，以及锁的剩余时间，进行自旋，</p><p>在加锁成功的同时会启用一个<code>watch dog</code>的后台线程，每隔10秒进行检查，判断是否需要续期</p><p><strong>解锁：</strong></p><p>由于是可重入锁，当val值为0时表示不再持有锁，通过<code>pub/sub</code>的方式进行释放锁执行<code>del lock</code></p><h4 id="_1-2-5-redlock" tabindex="-1"><a class="header-anchor" href="#_1-2-5-redlock" aria-hidden="true">#</a> 1.2.5 RedLock</h4><p>RedLock的大概流程是先有多于5个的Redis实例，然后分别向各个实例请求加锁，当大于半数加锁成功就认为是加锁成功，释放锁时操作所有节点</p><p>但是要考虑加锁的耗时，网络等原因</p><h3 id="_1-3-基于zookeeper的分布式锁" tabindex="-1"><a class="header-anchor" href="#_1-3-基于zookeeper的分布式锁" aria-hidden="true">#</a> 1.3 基于ZooKeeper的分布式锁</h3><p>ZooKeeper实现的分布式锁:</p><ol><li>客户端1创建临时节点（会产生惊群效应，一般使用临时有序节点） 如<code>/lock</code></li><li>客户端2尝试创建临时节点失败，加锁失败，</li><li>客户端1操作共享资源完成后，删除<code>/lock</code>节点，释放锁，客户端2通过watcher机制发现可以加锁</li></ol><p><strong>可能有的问题</strong>: ZooKeeper长时间收不到客户端的心跳(例如GC或者网络延迟)，也会把临时节点删除，导致其他客户端提前拿到了锁，但是原客户端认为自己有锁</p><blockquote><p>ZooKeeper和Redis实现分布式锁的优劣</p><p>ZooKeeper实现简单，不需要考虑锁的过期时间，通过<code>watcher</code>加锁失败可以等待锁的释放，实现乐观锁，</p><p>但是ZooKeeper的部署和运维成本高，性能上不如Redis，也存在着客户端与ZooKeeper长时间失联导致的锁提前释放的问题</p></blockquote><h2 id="_2-分布式缓存" tabindex="-1"><a class="header-anchor" href="#_2-分布式缓存" aria-hidden="true">#</a> 2. 分布式缓存</h2><blockquote><p>前端有页面和浏览器缓存，Application Cache，localStore等，</p><p>网络传输缓存，会有多层缓存，CDN,负载均衡，</p><p>服务端缓存，本地缓存:Guava,Map,Caffine,外部缓存大多数服务端缓存采用redis，</p><p>数据库缓存,MyBtais的一二级缓存，MySQL的缓存</p></blockquote><h3 id="_2-1-redis的持久化-高可用-过期策略-缓存异常问题-缓存和数据库双写一致性问题" tabindex="-1"><a class="header-anchor" href="#_2-1-redis的持久化-高可用-过期策略-缓存异常问题-缓存和数据库双写一致性问题" aria-hidden="true">#</a> 2.1 Redis的持久化，高可用，过期策略，缓存异常问题，缓存和数据库双写一致性问题</h3>',20),m={href:"https://spectred.github.io/interview/redis.html",target:"_blank",rel:"noopener noreferrer"},v=s('<h2 id="_3-分布式事务" tabindex="-1"><a class="header-anchor" href="#_3-分布式事务" aria-hidden="true">#</a> 3. 分布式事务</h2><blockquote><p>分布式事务指多个服务同时访问多个数据源的事务处理机制。主流的方案有2PC,3PC,TCC,可靠事件队列,SAGA事务</p></blockquote><h3 id="_3-1-2pc-两阶段提交" tabindex="-1"><a class="header-anchor" href="#_3-1-2pc-两阶段提交" aria-hidden="true">#</a> 3.1 2PC 两阶段提交</h3><p>存在协调者和参与者，准备阶段: 协调者询问参与者是否可正常执行，参与者执行事务但不提交；提交阶段: 协调者通知参与提交，参与者进行提交，如果有失败则整体回滚</p><p>存在的问题： 资源被同步阻塞，协调者单点故障</p><blockquote><p>典型应用: <strong>MySQL的主从复制</strong></p><p>MySQL使用2PC，内部自动将普通事务当做一个XA事务(内部分布式事务)来保证<code>binlog</code>和<code>redolog</code>的一致性:</p><ul><li>Commit会被自动分成Prepare和Commit两个阶段</li><li>binlog会被当做事务协调者，binlog event会被当做协调者日志</li></ul></blockquote><h3 id="_3-2-3pc-三阶段提交" tabindex="-1"><a class="header-anchor" href="#_3-2-3pc-三阶段提交" aria-hidden="true">#</a> 3.2 3PC 三阶段提交</h3><p>为解决2PC的同步阻塞问题，3PC在协调者和参与者中都引入了超时机制。</p><p><code>CanCommit</code>： 协调者询问参与者是否可正常执行，参与者预估判断是否可执行，不做事务操作</p><p><code>PreCommit</code>： 协调者询问参与者是否可正常执行，参与者执行事务但不提交</p><p><code>DoCommit</code>： 协调者向所有参与者发起事务提交通知，参与者收到通知或者超时提交事务向协调者反馈结果</p><p>改进内容: 引入超时机制，添加预提交阶段</p><p>存在的问题： 第三阶段中，如果参与者收到了<code>PreCommit</code>消息后，出现了不能正常通信的问题，参与者依然会提交事务导致数据不一致</p><h3 id="_3-3-tcc" tabindex="-1"><a class="header-anchor" href="#_3-3-tcc" aria-hidden="true">#</a> 3.3 TCC</h3><blockquote><p>TCC基于业务层面的事务定义，锁粒度由业务自己控制，为了解决复杂业务中跨表跨库等大粒度资源锁定的问题。</p><p>TCC把事务运行过程分成 Try,Confirm/Cancel两个阶段，每个阶段逻辑由业务控制，避免长事务，可以获取更高性能</p></blockquote><p><code>Try</code>： 调用Try接口，尝试执行业务，完成所有业务检查，预留业务资源</p><p><code>Confirm</code>/<code>Cancel</code>：两者互斥，只能进入其中一个，并且都满足幂等性，允许失败重试</p><ul><li><code>Confirm</code>： 对业务系统做确认提交，确认执行业务操作，不做其他业务检查，只使用Try阶段预留的业务资源</li><li><code>Cancel</code>: 在业务执行错误，需要回滚的状态下执行业务取消，释放预留资源</li></ul><p>缺点: 侵入型强，事务管理器需要记录事务日志损耗性能</p><h3 id="_3-4-基于mq的可靠消息投递方案-最大努力交付" tabindex="-1"><a class="header-anchor" href="#_3-4-基于mq的可靠消息投递方案-最大努力交付" aria-hidden="true">#</a> 3.4 基于MQ的可靠消息投递方案(最大努力交付)</h3><ol><li><p>提交本地事务，向MQ发送消息，并将消息状态落库到消息表，</p></li><li><p>其他服务消费消息后提交本地事务，更新消息表，双向确认，</p></li><li><p>如果有问题需要手动/定时批量扫描进行补偿</p></li></ol><p>支持分布式事务的消息框架如RocketMQ原生就支持分布式事务操作</p><h3 id="_3-5-saga事务" tabindex="-1"><a class="header-anchor" href="#_3-5-saga事务" aria-hidden="true">#</a> 3.5 SAGA事务</h3><p>将一个大事务拆分成若干个小事务T1,T2...Tn,每个子事务设计对应的补偿动作C1,C2...Cn</p><p>有两种恢复策略</p><ul><li>正向恢复: 如果其中一个子事务提交失败，则对这个子事务一直重试至成功，不需要补偿 ，例如扣款了就要发货</li><li>反向恢复: 如果其中一个子事务提交失败，则一直执行对应的补充动作进行补偿直至成功</li></ul>',26),C={id:"_3-6-⭐️seata",tabindex:"-1"},q=e("a",{class:"header-anchor",href:"#_3-6-⭐️seata","aria-hidden":"true"},"#",-1),E={href:"http://seata.io/zh-cn/",target:"_blank",rel:"noopener noreferrer"},y=e("blockquote",null,[e("p",null,"Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务")],-1),A=e("h2",{id:"_4-分布式消息队列",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_4-分布式消息队列","aria-hidden":"true"},"#"),a(" 4. 分布式消息队列")],-1),w={href:"https://spectred.github.io/interview/kafka.html",target:"_blank",rel:"noopener noreferrer"},S=e("h2",{id:"_5-分布式存储",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-分布式存储","aria-hidden":"true"},"#"),a(" 5. 分布式存储")],-1),T=e("h3",{id:"_5-1-读写分离",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-1-读写分离","aria-hidden":"true"},"#"),a(" 5.1 读写分离")],-1),B=e("blockquote",null,[e("p",null,"适用于读多写少")],-1),R=e("p",null,"为了不让数据库的读成为业务瓶颈，同时也为了保证写库的成功率，一般采用读写分离保证。可一主一从，一主多从",-1),P={href:"https://spectred.github.io/interview/mysql.html#_16-mysql%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84",target:"_blank",rel:"noopener noreferrer"},L=e("h3",{id:"_5-2-分库分表",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-2-分库分表","aria-hidden":"true"},"#"),a(" 5.2 分库分表")],-1),K=e("blockquote",null,[e("p",null,"单表行数超过500万行或者单表容量超过2GB，才推荐分库分表")],-1),M={href:"https://spectred.github.io/interview/mysql.html#_17-%E5%85%B3%E4%BA%8E%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8",target:"_blank",rel:"noopener noreferrer"},Z=s('<p>分库分表后，会引入分布式事务的问题，跨库关联查询(字段冗余)，跨库跨表的合并和排序(依赖分库分表中间件)</p><h2 id="_6-分布式基础理论" tabindex="-1"><a class="header-anchor" href="#_6-分布式基础理论" aria-hidden="true">#</a> 6. 分布式基础理论</h2><h3 id="_6-1-cap理论" tabindex="-1"><a class="header-anchor" href="#_6-1-cap理论" aria-hidden="true">#</a> 6.1 CAP理论</h3><p>CAP理论描述了在一个分布式系统中，涉及共享数据问题时，以下三个特性最多只能同步满足其中两个:</p><ul><li>Consistency <strong>一致性</strong>: 数据在任何时刻任何分布式节点中所看大的都是符合预期的</li><li>Availability <strong>可用性</strong>: 系统不间断地提供服务能力</li><li>Partition Tolerance <strong>分区容忍性</strong>: 分布式环境中部分节点因网络原因而彼此失联后，系统仍能正确的提供服务的能力</li></ul><h3 id="_6-2-base达成最终一致性" tabindex="-1"><a class="header-anchor" href="#_6-2-base达成最终一致性" aria-hidden="true">#</a> 6.2 BASE达成最终一致性</h3><blockquote><p>ACID保证强一致性</p></blockquote><ul><li>Basically Available 基本可用性</li><li>Soft State 柔性事务</li><li>Eventually Consistent 最终一致性</li></ul><h3 id="_6-3-分布式共识" tabindex="-1"><a class="header-anchor" href="#_6-3-分布式共识" aria-hidden="true">#</a> 6.3 分布式共识</h3><blockquote><p>目前面试还没被问过，被问到时再补充吧...😄</p></blockquote><h4 id="_6-3-1-paxos" tabindex="-1"><a class="header-anchor" href="#_6-3-1-paxos" aria-hidden="true">#</a> 6.3.1 Paxos</h4><h4 id="_6-3-2-multi-paxos" tabindex="-1"><a class="header-anchor" href="#_6-3-2-multi-paxos" aria-hidden="true">#</a> 6.3.2 Multi Paxos</h4><h4 id="_6-3-3-gossip" tabindex="-1"><a class="header-anchor" href="#_6-3-3-gossip" aria-hidden="true">#</a> 6.3.3 Gossip</h4><h4 id="_6-3-4-raft" tabindex="-1"><a class="header-anchor" href="#_6-3-4-raft" aria-hidden="true">#</a> 6.3.4 Raft</h4>',14);function G(Q,D){const o=i("ExternalLinkIcon");return r(),d("div",null,[l,e("blockquote",null,[e("p",null,[a("👍🏻 "),e("a",p,[a("凤凰架构"),n(o)])])]),h,e("blockquote",null,[e("p",null,[e("a",u,[a("深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了！"),n(o)])]),e("p",null,[e("a",_,[a("Redisson-8.分布式锁和同步器"),n(o)])])]),k,e("h4",b,[f,a(" 1.2.4 使用"),e("a",x,[a("Redisson"),n(o)])]),g,e("blockquote",null,[e("p",null,[e("a",m,[a("https://spectred.github.io/interview/redis.html"),n(o)])])]),v,e("h3",C,[q,a(" 3.6 ⭐️"),e("a",E,[a("Seata"),n(o)])]),y,A,e("blockquote",null,[e("p",null,[e("a",w,[a("https://spectred.github.io/interview/kafka.html"),n(o)])])]),S,T,B,R,e("p",null,[e("a",P,[a("MySQL的主从复制"),n(o)])]),L,K,e("p",null,[e("a",M,[a("分库分表"),n(o)])]),Z])}const V=t(c,[["render",G],["__file","distributed.html.vue"]]);export{V as default};
