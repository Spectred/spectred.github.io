import{ab as r,G as l,H as t,E as e,S as o,N as d,ac as c,W as n}from"./framework-11534bf9.js";const i={},p=e("h1",{id:"java",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#java","aria-hidden":"true"},"#"),o(" Java")],-1),h={href:"https://docs.oracle.com/en/java/",target:"_blank",rel:"noopener noreferrer"},s={href:"https://openjdk.org",target:"_blank",rel:"noopener noreferrer"},u={href:"https://book.douban.com/subject/34907497/",target:"_blank",rel:"noopener noreferrer"},_={href:"http://47.103.216.138/",target:"_blank",rel:"noopener noreferrer"},b=c('<h2 id="_1-如何保证线程安全" tabindex="-1"><a class="header-anchor" href="#_1-如何保证线程安全" aria-hidden="true">#</a> 1. 如何保证线程安全</h2><blockquote><p>线程安全：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的</p></blockquote><h3 id="_1-1-互斥同步-阻塞同步" tabindex="-1"><a class="header-anchor" href="#_1-1-互斥同步-阻塞同步" aria-hidden="true">#</a> 1.1 互斥同步(阻塞同步)</h3><ol><li><p><code>synchronized</code></p></li><li><p><code>Lock</code>: 例如<code>ReentrantLock</code></p></li></ol><blockquote><p><code>synchronized</code>和<code>ReentrantLock</code>的区别:</p><ul><li><p><code>synchronized</code>是在Java语法层面的同步，<code>ReentrantLock</code>是Java语言层面，释放锁要确保在<code>finally</code>块中释放锁</p></li><li><p>性能上差不太多，但是两者都可满足需要时优先使用<code>synchronized</code></p></li><li><p><code>ReentrantLock</code>相比<code>synchronized</code>相比增加了一些高级功能:</p></li></ul><p><strong>等待可中断</strong>: 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</p><p><strong>公平锁</strong>: 多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁,<code>ReentrantLock</code>使用公平锁将会导致性能下降</p><p><strong>锁绑定多个条件</strong>: 一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象,需要多次调用<code>newCondition()</code>，<code>synchronized</code>需要额外添加锁</p></blockquote><h3 id="_1-2-无锁编程-非阻塞同步" tabindex="-1"><a class="header-anchor" href="#_1-2-无锁编程-非阻塞同步" aria-hidden="true">#</a> 1.2 无锁编程(非阻塞同步)</h3><blockquote><p>不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功；如果共享的数据被争用产生了冲突，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止</p></blockquote><p>基于<code>CAS</code>的操作：</p><ul><li>使用<code>Unsafe.compareAndSet</code>方法，</li><li>基于<code>CAS</code>的<code>j.u.c</code>包中的原子类（<code>AtomicInteger</code>等）</li><li>使用<code>j.u.c</code>中的线程安全的并发集合,如<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>CopyOnWriteArrayList</code></li></ul><blockquote><p><code>CAS</code>操作的<code>ABA</code>问题</p><p>如果一个变量V初次读取的时候是A值，其他线程把它修改为B,又修改回为A,那<code>CAS</code>操作就会误认为它从来没有修改过</p><p>如何解决: 使用版本或者时间戳，例如<code>AtomicStampedReference</code>,但是大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决，传统的互斥同步可能会比原子类更高效</p></blockquote><h3 id="_1-3-无同步方案" tabindex="-1"><a class="header-anchor" href="#_1-3-无同步方案" aria-hidden="true">#</a> 1.3 无同步方案</h3><blockquote><p>同步与线程安全两者没有必然的联系</p></blockquote><p>线程本地存储： 通过<code>ThreadLocal</code>实现</p><blockquote><p>每一个线程的<code>Thread</code>对象中都有一个<code>ThreadLocalMap</code>对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，以本地线程变量为值的<code>K-V</code>键值对，<code>ThreadLocal</code>就是当前线程的<code>ThreadLocalMap</code>的访问入口，每一个<code>ThreadLocal</code>对象都包含一个唯一的<code>threadLocalHashCode</code>值，使用这个值就可以在线程<code>K-V</code>值对中找回对应的本地线程变量</p></blockquote><h2 id="_2-unsafe如果获取-能做哪些操作" tabindex="-1"><a class="header-anchor" href="#_2-unsafe如果获取-能做哪些操作" aria-hidden="true">#</a> 2. <code>Unsafe</code>如果获取，能做哪些操作</h2>',15),k={href:"https://spectred.github.io/java/magic/unsafe.html",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,[o("可以通过反射来获取"),e("code",null,"Unsafe"),o("实例，可以实例化一个类、修改私有属性值、"),e("code",null,"CAS"),o("操作、使用堆外内存和锁的"),e("code",null,"park/unpark"),o("操作")],-1),m=e("h2",{id:"_3-lambda是如何实现的",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-lambda是如何实现的","aria-hidden":"true"},"#"),o(" 3. "),e("code",null,"lambda"),o("是如何实现的")],-1),g={href:"https://developer.aliyun.com/article/712461",target:"_blank",rel:"noopener noreferrer"},v={href:"https://stackoverflow.com/questions/29143803/java-lambdas-how-it-works-in-jvm-is-it-oop",target:"_blank",rel:"noopener noreferrer"},q={href:"https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood/",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,[e("code",null,"lambda"),o("引导方法动态生成一个匿名类字节码")],-1),A=e("h2",{id:"_4-volatile-关键字",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_4-volatile-关键字","aria-hidden":"true"},"#"),o(" 4. "),e("code",null,"volatile"),o(" 关键字")],-1),L={href:"https://www.hollischuang.com/archives/2550",target:"_blank",rel:"noopener noreferrer"},j={href:"https://www.hollischuang.com/archives/2648",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.hollischuang.com/archives/2673",target:"_blank",rel:"noopener noreferrer"},T=c('<h3 id="_4-1-先从java内存模型-jmm-java-memory-model-说起" tabindex="-1"><a class="header-anchor" href="#_4-1-先从java内存模型-jmm-java-memory-model-说起" aria-hidden="true">#</a> 4.1 先从Java内存模型(<code>JMM</code>，<code>Java Memory Model</code>)说起</h3><p>Java内存模型规定所有的变量都存储在主内存，每条线程有自己的工作内存。</p><p>线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的数据。</p><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p><h3 id="_4-2-volatile有哪些作用" tabindex="-1"><a class="header-anchor" href="#_4-2-volatile有哪些作用" aria-hidden="true">#</a> 4.2 <code>volatile</code>有哪些作用</h3><p>当一个变量被定义成<code>volatile</code>之后会具备<strong>可见性</strong>和<strong>有序性</strong>两项特性</p><ul><li><p><strong>可见性</strong></p><p>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。但是不能保证原子性，不是线程安全的</p><blockquote><p><code>synchronized</code>和<code>final</code>关键字也保证了可见性</p><ul><li><code>synchronized</code>： 对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中</li><li><code>final</code>： 被<code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有吧<code>this</code>的引用传递出去，那么其他线程就可以看见<code>final</code>字段的值</li></ul></blockquote></li><li><p><strong>有序性</strong> (禁止指令重排序优化)</p><p>有序性即程序执行的顺序按照代码的先后顺序执行</p><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的</p><blockquote><p><code>synchronized</code>也可以保证有序性: 通过 一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作规则获得</p></blockquote></li></ul><h3 id="_4-3-volatile如何实现可见性和有序性的-实现的原理是什么" tabindex="-1"><a class="header-anchor" href="#_4-3-volatile如何实现可见性和有序性的-实现的原理是什么" aria-hidden="true">#</a> 4.3 <code>volatile</code>如何实现可见性和有序性的(实现的原理是什么)?</h3><p>可见性: 被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新</p><p>有序性: 禁止指令重排序优化,内存屏障</p><h3 id="_4-4-什么是happens-before-先行发生-原则" tabindex="-1"><a class="header-anchor" href="#_4-4-什么是happens-before-先行发生-原则" aria-hidden="true">#</a> 4.4 什么是<code>Happens-Before</code>(先行发生)原则</h3><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系</p><ul><li><code>volatile</code>变量规则: 被其修饰的变量的写操作先发生于读操作</li><li>程序次序规则: 在一个线程内，按照控制流顺序，前面的操作先发生在书写在后边的操作</li><li>线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性</li></ul><h2 id="_5-锁优化有哪些技术-自旋-锁消除-锁膨胀" tabindex="-1"><a class="header-anchor" href="#_5-锁优化有哪些技术-自旋-锁消除-锁膨胀" aria-hidden="true">#</a> 5. 锁优化有哪些技术?（自旋，锁消除，锁膨胀）</h2><h3 id="_5-1-自旋锁与自适应自旋" tabindex="-1"><a class="header-anchor" href="#_5-1-自旋锁与自适应自旋" aria-hidden="true">#</a> 5.1 自旋锁与自适应自旋</h3><p><strong>自旋</strong>: 如果有两个或两个以上的线程同时执行，让后面请求锁的线程&quot;稍等一会&quot;，但不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁。为了让线程等待，需要让线程执行一个忙循环(自旋)</p><p>如果锁被占用的时间很长，自旋的线程只会白白消耗处理器资源，带来性能的浪费，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式挂起线程。自旋次数默认是10次，通过<code>-XX:PreBlockSpin</code>来指定</p><p><strong>自适应自旋</strong>: 自旋的时间不固定，而是由上一次在同一个锁上的自旋时间和锁的拥有者状态来决定的</p><blockquote><p>如果上一次很快获得锁，那么再次获锁时可以等上很多次；如果上一次很少成功获锁，那么再次获锁时有可能直接忽略掉自旋，避免处理器资源浪费</p></blockquote><h3 id="_5-2-锁消除" tabindex="-1"><a class="header-anchor" href="#_5-2-锁消除" aria-hidden="true">#</a> 5.2 锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除</p><p>锁消除的主要判断依据来源于<strong>逃逸分析</strong>的数据支持，如果判断代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做是栈上的数据进行对待，认为是线程私有的，同步加锁也就无需再进行</p><h3 id="_5-3-锁膨胀-锁升级" tabindex="-1"><a class="header-anchor" href="#_5-3-锁膨胀-锁升级" aria-hidden="true">#</a> 5.3 锁膨胀(锁升级)</h3><p>锁膨胀是通过对象头中的<code>MarkWord</code>的锁标志位实现的</p><p>当使用<code>synchronized</code>时，（如果没有使用，处于<strong>无锁</strong>状态），</p><ul><li><p><strong>偏向锁</strong>（01）: 锁会偏向第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有<strong>偏向锁</strong>的线程将永远不需要进行同步，</p></li><li><p><strong>轻量锁</strong>（00）: 偏向锁时被另一个线程访问，升级为轻量锁，此线程会自旋获锁，不会阻塞</p></li><li><p><strong>重量锁</strong>（10）: 轻量锁时，自旋的线程自旋一定次数后还没有获锁，进入阻塞升级为重量锁，阻塞其他线程，性能降低</p></li></ul><h2 id="_6-java中线程有哪些状态-各个状态间是如何转换的" tabindex="-1"><a class="header-anchor" href="#_6-java中线程有哪些状态-各个状态间是如何转换的" aria-hidden="true">#</a> 6. Java中线程有哪些状态，各个状态间是如何转换的</h2><blockquote><p>在<code>java.lang.Thread.State</code>中定义了6种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换</p></blockquote><ul><li><p><code>NEW</code> 新建</p><p>创建后尚未启动的线程处于这种状态</p></li><li><p><code>RUNNABLE</code> 运行</p><p><code>Thread#start()</code>包括操作系统线程状态中的<code>Running</code>和<code>Ready</code>,处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间</p></li><li><p><code>WAITING</code> 无限期等待</p><p>处于这中状态的线程不会被分配处理器执行时间，他们要等待被其他线程显示唤醒,<code>Object::wait()</code>,<code>Thread.join()</code>,<code>LockSupport::park()</code></p></li><li><p><code>TIMED_WAITING</code> 限期等待</p><p>处于这种状态的线程也不会被分配处理器执行时间，不过无需等待被其他线程显式唤醒，在一定时间之后他们会由系统自动唤醒</p></li></ul><p>​ <code>Thread.sleep， Object.wait with timeout， Thread.join with timeout，LockSupport.parkNanos， LockSupport.parkUntil</code></p><ul><li><p><code>BLOCKED</code> 阻塞</p><p>线程被阻塞，<code>synchronized</code></p></li><li><p><code>TERMINATED</code> 结束</p><p>线程已结束执行</p></li></ul><h2 id="_7-线程池的参数-工作流程-有哪些拒绝策略-如何回收线程" tabindex="-1"><a class="header-anchor" href="#_7-线程池的参数-工作流程-有哪些拒绝策略-如何回收线程" aria-hidden="true">#</a> 7. 线程池的参数，工作流程，有哪些拒绝策略，如何回收线程</h2><blockquote><p><code>java.util.concurrent.ThreadPoolExecutor</code></p></blockquote><ul><li><p><code>corePoolSize</code>核心线程数，</p></li><li><p><code>maximumPoolSize</code>最大线程数，</p></li><li><p><code>keepAliveTime</code>+<code>unit</code>： 如果一个线程处于闲置(<code>idle</code>)状态并且当前的线程数量大于核心线程数，在指定时间后这个线程会被销毁</p></li><li><p><code>workQueue</code> 在执行任务之前保存任务的队列</p></li><li><p><code>threadFactory</code> 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等</p></li><li><p><code>rejectedExecutionHandler</code> 拒绝策略，有4种: 抛出异常，直接丢弃(不抛异常），丢弃任务队列中等待时间最长的，谁提交任务谁来执行这个任务</p></li></ul><p><strong>工作流程</strong></p><p>如果当前线程数量小于核心线程就创建核心线程，如果大于核心线程数就放到工作队列中，如果工作队列满了并且小于最大线程数，就创建非核心线程，如果大于最大线程数就采取拒绝策略</p><p><strong>如何回收线程</strong></p><p>线程池中的线程分为核心线程和非核心线程，核心线程常驻线程池，当工作任务队列满时，将会创建非核心线程来处理任务，当任务处理完成后，在一定时间内空闲的线程需要被回收，需要用到工作任务队列-阻塞队列中的<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code>方法，如果返回<code>null</code>则可以进行回收(调用<code>Thread#interrupt()</code>)</p><p>默认情况下只会回收非核心线程，当<code>allowCoreThreadTimeOut</code>为<code>true</code>时也会回收核心线程，一般不要回收核心线程</p><h2 id="_8-并行流stream-parallelstream可能有哪些问题" tabindex="-1"><a class="header-anchor" href="#_8-并行流stream-parallelstream可能有哪些问题" aria-hidden="true">#</a> 8. 并行流<code>Stream.parallelStream</code>可能有哪些问题</h2><p><code>Stream.parallelStream</code>默认是通过<code>ForkJoinPool.commonPool</code>线程池来实现的，将流分为多个子流到不同的CPU中处理然后合并处理结果</p><p>可能产生的问题: 共享资源的竞争，线程安全，死锁，线程切换，事务等</p><h2 id="_9-什么是内存泄露-什么情况会导致内存泄露-如何解决" tabindex="-1"><a class="header-anchor" href="#_9-什么是内存泄露-什么情况会导致内存泄露-如何解决" aria-hidden="true">#</a> 9. 什么是内存泄露，什么情况会导致内存泄露，如何解决</h2><p>当对象已经不再被使用，但是垃圾回收期不能回收的时候，产生内存泄露</p><p>未引用对象将会被垃圾回收，而引用对象却不会，未引用对象是无用的对象，无用的对象并不都是未引用对象，有一些无用对象有可能是引用对象，这部分是内存泄露的来源</p><p>如果对象A引用对象B。A的生命周期比B的生命周期要长，当B在程序中不再被使用的时候，A仍然引用着B，在这种情况下，垃圾回收器是不会回收对象B的，可能造成内存不足的问题，因为A可能不止引用着B，还可能引用其他生命周期比A短的对象，造成了大量无用对象不能被回收，且占据内存资源，同样B也可能引用其他对象，这些被B对象引用着的对象也不能被垃圾回收器回收，所有的无用对象消耗大量内存</p><p><strong>怎样阻止内存泄露</strong></p><ul><li>使用List Map等集合或者大对象时，使用完成后赋值为null</li><li>避免死循环创建或对集合添加元素</li><li>及时关闭打开的文件等</li></ul>',48);function S(y,B){const a=n("ExternalLinkIcon");return l(),t("div",null,[p,e("blockquote",null,[e("p",null,[e("a",h,[o("Java Documentation"),d(a)])]),e("p",null,[e("a",s,[o("OpenJDK"),d(a)])]),e("p",null,[e("a",u,[o("深入理解Java虚拟机"),d(a)])]),e("p",null,[e("a",_,[o("HollisChuang's Blog"),d(a)])])]),b,e("blockquote",null,[e("p",null,[e("a",k,[o("https://spectred.github.io/java/magic/unsafe.html"),d(a)])])]),f,m,e("blockquote",null,[e("p",null,[e("a",g,[o("Lambda 底层实现分析"),d(a)])]),e("p",null,[e("a",v,[o("Java Lambdas : How it works in JVM & is it OOP?"),d(a)])]),e("p",null,[e("a",q,[o("Java 8 Lambdas - A Peek Under the Hood"),d(a)])])]),x,A,e("blockquote",null,[e("p",null,[e("a",L,[o("再有人问你Java内存模型是什么，就把这篇文章发给他。"),d(a)])]),e("p",null,[e("a",j,[o("深入理解Java中的volatile关键字"),d(a)])]),e("p",null,[e("a",w,[o("再有人问你volatile是什么，把这篇文章也发给他。"),d(a)])])]),T])}const C=r(i,[["render",S],["__file","java.html.vue"]]);export{C as default};
