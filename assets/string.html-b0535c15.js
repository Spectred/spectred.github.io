import{_ as a,V as i,W as o,Z as e,$ as r,Y as n,a4 as s,F as d}from"./framework-eedf5ae1.js";const l={},c=e("h1",{id:"string",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#string","aria-hidden":"true"},"#"),r(" String")],-1),h={href:"https://redis.io/docs/data-types/strings",target:"_blank",rel:"noopener noreferrer"},g={href:"https://redis.io/commands/?group=string",target:"_blank",rel:"noopener noreferrer"},p={href:"https://github.com/Spectred/redis/blob/spectred_6.2/src/t_string.c",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/Spectred/redis/blob/spectred_6.2/src/sds.h",target:"_blank",rel:"noopener noreferrer"},b=e("h2",{id:"数据结构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#数据结构","aria-hidden":"true"},"#"),r(" 数据结构")],-1),u=e("ul",null,[e("li",null,"如果value是64位有符号整数，Redis保存为8字节的Long类型整数(int编码方式)"),e("li",null,"如果value中包含字符串，Redis使用SDS(Simple Dynamic String)结构体保存")],-1),f=e("h3",{id:"数据结构定义",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#数据结构定义","aria-hidden":"true"},"#"),r(" 数据结构定义")],-1),m={href:"https://github.com/Spectred/redis/blob/unstable/src/sds.h",target:"_blank",rel:"noopener noreferrer"},k=s(`<div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;            /* buf的已用长度,占4个字节 */
    uint8_t alloc;          /* buf的实际分配长度,占4个字节, 排除了header和null终止符 */
    unsigned char flags;    /* SDS类型,和SDS_TYPE_MASK计算出是sdshdr5/8/16/32/64 */
    char buf[];             /* 实际数据 */
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>__attribute__ ((__packed__))</code>表示 告诉编译器在对结构体进行内存对齐时不要进行字节对齐填充，采用紧凑的方式分配内存。默认如果变量5个字节，不够8字节也会分配8字节，使用后只有5个字节。</p><div class="hint-container note"><p class="hint-container-title">注</p><p>和JDK中的@Contended的异同</p></div><h3 id="redisobject" tabindex="-1"><a class="header-anchor" href="#redisobject" aria-hidden="true">#</a> RedisObject</h3>`,4),S={href:"https://time.geekbang.org/column/article/279649",target:"_blank",rel:"noopener noreferrer"},v={href:"https://static001.geekbang.org/resource/image/34/57/3409948e9d3e8aa5cd7cafb9b66c2857.jpg",target:"_blank",rel:"noopener noreferrer"},x={href:"https://time.geekbang.org/column/article/279649",target:"_blank",rel:"noopener noreferrer"},D={href:"https://static001.geekbang.org/resource/image/ce/e3/ce83d1346c9642fdbbf5ffbe701bfbe3.jpg",target:"_blank",rel:"noopener noreferrer"},j=e("h3",{id:"sds关键函数",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#sds关键函数","aria-hidden":"true"},"#"),r(" SDS关键函数")],-1),C={href:"https://github.com/Spectred/redis/blob/spectred_6.2/src/sds.c",target:"_blank",rel:"noopener noreferrer"},R=s('<p>😈图中函数可能和新版本有出入 <img src="https://s2.loli.net/2023/09/13/3nT8eFVHgpXckGC.jpg" alt="http://redisbook.com/" loading="lazy"></p><div class="hint-container info"><p class="hint-container-title">Redis为什么使用SDS，而不是char*</p><p>背景：C语言中使用char<em>字符数组来实现字符串，char</em>指针指向字符数组起始位置，\\0表示字符串的结尾</p><p>为什么不用char*字符数组（因/0带来的问题）：</p><ol><li>不能存储任意格式数据（例如二进制）</li><li>操作字符串获取长度需要遍历到\\0，效率不高 O(N)</li></ol><p>为什么使用SDS(SDS的优势)（需要掌握SDS结构）：</p><ol><li>len + buf 1.1 由于使用len属性表示长度，可以规避\\0的问题，即能存储二进制（buf[])，获取长度直接使用属性值，O（1） 1.2 拼接字符串会检查空间大小是否满足，避免缓冲区溢出</li><li>flags + alloc +len 2.1 有多种类型的SDS(flags表示类型，len alloc区分长度)，存储长度不同的字符串 2.2 <strong>attribute</strong> ((<strong>packed</strong>))编译优化，采用紧凑方式分配内存 2.3 字符串内部编码优化，有int raw embstr三种</li></ol><p>个人理解：从“降本增效”的角度来看（降低内存使用，增加操作效率）</p><ol><li>降本：多种结构头存储不同大小字符串，紧凑型分配内存，内部编码优化</li><li>增效：使用len提升效率,避免遍历到\\0，基于长度的操作（如复制、追加）提升效率</li><li>功能上可以存储二进制数据</li></ol><p>引用《Redis设计与实现》中的图: <img src="https://s2.loli.net/2023/09/13/PUng9ikxzwZIRJ1.jpg" alt="http://redisbook.com/" loading="lazy"></p></div><h3 id="redis中的string有哪些不足" tabindex="-1"><a class="header-anchor" href="#redis中的string有哪些不足" aria-hidden="true">#</a> Redis中的String有哪些不足</h3>',3);function V(N,y){const t=d("ExternalLinkIcon");return i(),o("div",null,[c,e("p",null,[e("a",h,[r("数据类型: string"),n(t)])]),e("p",null,[e("a",g,[r("命令: string"),n(t)])]),e("p",null,[e("a",p,[r("命令源码 t_string.c"),n(t)])]),e("p",null,[e("a",_,[r("数据结构 sds"),n(t)])]),b,u,f,e("p",null,[r("在"),e("a",m,[r("sds.h"),n(t)]),r("中定义如下结构体(包括sdshdr5,sdshdr8,sdshdr16,sdshdr32,sdshdr64)")]),k,e("p",null,[r("!["),e("a",S,[r("https://time.geekbang.org/column/article/279649"),n(t)]),r("]"),e("a",v,[r("https://static001.geekbang.org/resource/image/34/57/3409948e9d3e8aa5cd7cafb9b66c2857.jpg"),n(t)]),r(") !["),e("a",x,[r("https://time.geekbang.org/column/article/279649"),n(t)]),r("]"),e("a",D,[r("https://static001.geekbang.org/resource/image/ce/e3/ce83d1346c9642fdbbf5ffbe701bfbe3.jpg"),n(t)]),r(")")]),j,e("p",null,[e("a",C,[r("sds.c"),n(t)])]),R])}const z=a(l,[["render",V],["__file","string.html.vue"]]);export{z as default};
